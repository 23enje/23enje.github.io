<!DOCTYPE html>
<html class="has-navbar-fixed-top">
<head>
    <meta charset="utf-8">
<title>스프링 프레임워크(Spring Framework) - 23enje&#39;s blog</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">




<meta name="description" content="">










<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">


<link rel="stylesheet" href="/css/style.css">


<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>
<link href="https://hangeul.pstatic.net/hangeul_static/css/nanum-gothic-coding.css" rel="stylesheet">
<link href="https://hangeul.pstatic.net/hangeul_static/css/nanum-square.css" rel="stylesheet">
<link href="https://hangeul.pstatic.net/hangeul_static/css/nanum-gothic.css" rel="stylesheet">
<link href="https://hangeul.pstatic.net/hangeul_static/css/nanum-barun-gothic.css" rel="stylesheet">
<link href="https://hangeul.pstatic.net/hangeul_static/css/nanum-square-round.css" rel="stylesheet">







<meta name="generator" content="Hexo 6.2.0"></head>
<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                <img src="/images/logo.png" alt="" height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item "
               href="/archives">Archives</a>
            
            <a class="navbar-item "
               href="/categories/Documentation">Documentation</a>
            
            <a class="navbar-item "
               href="/tags">Tags</a>
            
            <a class="navbar-item "
               href="/about">About</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            
            
        </div>
    </div>
</nav>

    <section class="section">
    <div class="container">
    <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            스프링 프레임워크(Spring Framework)
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-04-25T09:15:58.000Z" itemprop="datePublished">4월 25 2022</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Documentation/">Documentation</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            25분 소요 (약 3755 단어)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <html><head></head><body><img src="/gallery/800px-Spring_Framework_Logo.png" class="">
<p>스프링 프레임워크(영어: Spring Framework)는 자바 플랫폼을 위한 오픈 소스 애플리케이션 프레임워크로서 간단히 스프링(Spring)이라고도 한다. 동적인 웹 사이트를 개발하기 위한 여러 가지 서비스를 제공하고 있다.</p>
<span id="more"></span>

<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="1-제어의-역전-Inversion-of-Control-IoC-의존성-주입-Dependency-Injection-DI"><a href="#1-제어의-역전-Inversion-of-Control-IoC-의존성-주입-Dependency-Injection-DI" class="headerlink" title="1. 제어의 역전(Inversion of Control, IoC), 의존성 주입(Dependency Injection, DI)"></a>1. 제어의 역전(Inversion of Control, IoC), 의존성 주입(Dependency Injection, DI)</h2><p>Spring 컨테이너는 IoC 컨테이너 또는 DI 컨테이너를 의미합니다. 스프링 규약에 의해 이런 Spring 컨테이너가 관리하는 객체를 보통 빈(Bean)이라고 부릅니다.<br>IoC는 DI로 알려져 있습니다. IoC란 객체가 자신 및 같이 작동하는 다른 객체의 의존성을 생성자 인자, 팩토리 메소드의 인자, 객체 인스턴스가 생성되거나 팩토리 메소드로부터 반환될 때 설정되는 프로퍼티를 통해서 정의하는 프로세스입니다. 그러면서 IoC 컨테이너는 Bean이 생성될 때 이러한 의존성을 주입합니다. 이 프로세스는 직접적으로 클래스들의 인자를 사용하거나 Service Locator Pattern과 같은 방법을 사용함으로서 의존성을 인스턴스화 하거나 위치를 제어하는 Bean의 입장에서 근본적으로 제어의 역전(IoC)이라 합니다.</p>
<p>제어의 역전(IoC)을 코드를 통해 알아봅시다.<br>객체의 의존성을 관리하기 위한 두가지 방법이 있습니다. 하나는 객체가 직접 의존 관계에 있는 객체들의 생성자를 호출하는 것으로 의존성을 인스턴스화하는 것입니다.  </p>
<p>다음의 RegistrationService는 회원 가입에 성공한 이후에 사용자에게 이메일을 전송하는 예제입니다.</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="title class_">RegistrationService</span> {</span><br><span class="line">  <span class="hljs-keyword">private</span> MailSender mailSender;</span><br><span class="line">  <span class="hljs-keyword">public</span> <span class="title function_">RegistrationService</span><span class="hljs-params">()</span> {</span><br><span class="line">    <span class="hljs-comment">// 의존하는 객체를 인스턴스화합니다.</span></span><br><span class="line">    <span class="hljs-built_in">this</span>.mailSender = <span class="hljs-keyword">new</span> <span class="title class_">MailSender</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="hljs-comment">// ... 나머지 로직</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>보다시피 RegistrationService는 MailSender를 인스턴스화함으로써 의존성을 관리합니다.  </p>
<p>다른 방법은 생성자 또는 세터를 통해 의존성을 주입하기 위해 스프링과 같은 컨테이너에 의존하여 제어의 역전이 발생된채 관리되는 것입니다.  </p>
<p>다음 RegistrationService는 기존 코드에서 제어의 역전을 보여주기 위해 변경한 예제입니다.  </p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="title class_">RegistrationService</span> {</span><br><span class="line">  <span class="hljs-keyword">private</span> MailSender mailSender;</span><br><span class="line">  <span class="hljs-keyword">public</span> <span class="title function_">RegistrationService</span><span class="hljs-params">(MailSender mailSender)</span> {</span><br><span class="line">    <span class="hljs-built_in">this</span>.mailSender = mailSender;</span><br><span class="line">  }</span><br><span class="line">  <span class="hljs-comment">// ... 나머지 로직</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>보다시피 RegistrationService 생성자의 인자로 MailSender 인스턴스를 추가합니다. 이 방법에서 RegistrationService는 의존성을 제어하지 못했습니다. 여기서 스프링이 MailSender 인스턴스를 인스턴스화하는 책임을 집니다. 의존성의 제어가 역전되었습니다. 이것을 제어의 역전(IoC)이라 부릅니다.</p>
<h2 id="2-스프링-IoC-컨테이너-Spring-IoC-Container"><a href="#2-스프링-IoC-컨테이너-Spring-IoC-Container" class="headerlink" title="2. 스프링 IoC 컨테이너(Spring IoC Container)"></a>2. 스프링 IoC 컨테이너(Spring IoC Container)</h2><p>스프링에서 org.springframework.context.ApplicationContext 인터페이스는 스프링 IoC 컨테이너를 의미합니다. 여기서 스프링은 클래스에 어떤 의존성이 필요한지 어떻게 알 수 있을까요? 스프링 컨테이너는 개발자가 정의한 설정 메타데이터(Configuration Metadata)를 사용하여 스프링 컨테이너의 객체를 인스턴스화하거나 구성 및 어셈블 하도록 지시합니다. 스프링 컨테이너를 설정하기 위한 방법은 ClassPathXmlApplicationContext를 사용하여 XML 기반 구성으로 설정하여 사용하였으나 스프링 3.0 이후부터는 대다수의 개발자들이 AnnotationConfigApplicationContext를 사용하여 자바 기반 구성을 설정하고 있습니다. ClassPathXmlApplicationContext 및 AnnotationConfigApplicationContext는 ApplicationContext 인터페이스의 구현체입니다.</p>
<h2 id="3-어노테이션-기반의-설정"><a href="#3-어노테이션-기반의-설정" class="headerlink" title="3. 어노테이션 기반의 설정"></a>3. 어노테이션 기반의 설정</h2><p>스프링은 의존성으로 관리할 수 있는 어노테이션 기반의 설정을 제공합니다. 이를 위해 스프링은 크게 두 가지 유형의 어노테이션을 제공합니다. 하나는 빈을 선언하는 어노테이션이고 다른 하나는 의존성을 연결하는 어노테이션입니다.</p>
<h3 id="3-1-빈-선언"><a href="#3-1-빈-선언" class="headerlink" title="3.1. 빈 선언"></a>3.1. 빈 선언</h3><p>스프링은 빈 선언을 위해 @Component, @Service, @Controller, @Repository를 포함한 스테레오 타입 어노테이션을 제공합니다. 스프링은 @ComponentScan 어노테이션에 입력한 기본 패키지부터 스캔해 해당 어노테이션이 달린 클래스를 수집합니다.<br>@ComponentScan 어노테이션은 제네릭 스트레오 타입입니다. 클래스에 이 어노테이션이 적용돼 있으면 스프링은 해당 클래스를 인스턴스화합니다. @service 어노테이션은 @Component를 특수화한 것이며 이 어노테이션이 적용된 클래스는 도메인 주도 설계(이하 “DDD”라 합니다.)에 사용된 용어인 서비스(Service)이거나 Core J2EE에서의 패턴인 비즈니스 서비스 Facade를 나타냅니다. @Repository 어노테이션은 컴포넌트가 DDD에서 사용된 용어인 리파지토리(Repository) 또는 Java EE 패턴인 DAO임을 나타냅니다. @Controller 어노테이션은 컴포넌트가 HTTP 요청을 받을 수 있는 웹 컨트롤러임을 나타냅니다.</p>
<h3 id="3-2-의존성-주입-Dependency-Injection"><a href="#3-2-의존성-주입-Dependency-Injection" class="headerlink" title="3.2. 의존성 주입(Dependency Injection)"></a>3.2. 의존성 주입(Dependency Injection)</h3><p>의존성을 연결하는 데는 스프링에서 제공하는 두 어노테이션인 @Required 어노테이션과 @Autowired 어노테이션을 사용할 수 있습니다. @Required 어노테이션을 세터 메소드에, @Autowired 어노테이션을 생성자와 메소드, 필드에 적용할 수 있습니다.</p>
<h4 id="3-2-1-생성자-기반의-주입"><a href="#3-2-1-생성자-기반의-주입" class="headerlink" title="3.2.1. 생성자 기반의 주입"></a>3.2.1. 생성자 기반의 주입</h4><p>@Autowired 어노테이션을 이용하여 생성자 기반 의존성을 주입한 예시 입니다.</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span> <span class="hljs-comment">// 해당 클래스에 빈 선언</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="title class_">MessageService</span> {</span><br><span class="line">  <span class="hljs-keyword">private</span> MessageRepository repository;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-meta">@Autowired</span> <span class="hljs-comment">// 생성자 기반의 주입(생략 가능)</span></span><br><span class="line">  <span class="hljs-keyword">public</span> <span class="title function_">MessageService</span> <span class="hljs-params">(MessageRepository repository)</span> {</span><br><span class="line">    <span class="hljs-built_in">this</span>.repository = repository;</span><br><span class="line">  }</span><br><span class="line">  ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>MessageRepository 빈은 MessageService 빈에 생성자를 통해 주입됩니다. Autowired는 생략이 가능합니다. 생략할 경우 스프링은 MessageRepository 빈을 삽입 해야 하므로 MessageService 생성자를 검사하면서 해당 인자의 유형을 찾습니다.</p>
<h4 id="3-2-2-세터-기반-x2F-메소드-기반의-주입"><a href="#3-2-2-세터-기반-x2F-메소드-기반의-주입" class="headerlink" title="3.2.2. 세터 기반/메소드 기반의 주입"></a>3.2.2. 세터 기반/메소드 기반의 주입</h4><p>일반적으로 세터 메소드를 선언하고 @Autowired 어노테이션 또는 @Required 어노테이션을 적용하는 것입니다.<br>다음은 @Required 어노테이션을 사용한 예시 입니다.</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="title class_">MessageService</span> {</span><br><span class="line">...</span><br><span class="line">  <span class="hljs-meta">@Required</span></span><br><span class="line">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="title function_">setRepository</span><span class="hljs-params">(MessageRepository repository)</span> {</span><br><span class="line">    <span class="hljs-built_in">this</span>.repository = repository;</span><br><span class="line">  }</span><br><span class="line">  ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>또는 @Autowired 어노테이션을 사용할 수 있습니다.</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="title class_">MessageService</span> {</span><br><span class="line">...</span><br><span class="line">  <span class="hljs-meta">@Autowired</span></span><br><span class="line">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="title function_">prepare</span><span class="hljs-params">(MessageRepository repository)</span> {</span><br><span class="line">    <span class="hljs-built_in">this</span>.repository = repository;</span><br><span class="line">  }</span><br><span class="line">  ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="3-2-3-필드-기반의-주입"><a href="#3-2-3-필드-기반의-주입" class="headerlink" title="3.2.3. 필드 기반의 주입"></a>3.2.3. 필드 기반의 주입</h4><p>@autowired 어노테이션으로 필드에 직접 적용할 수 있습니다. 이 경우 세터 메소드에 따로 선언할 필요가 없습니다.</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="title class_">MessageService</span> {</span><br><span class="line">  <span class="hljs-meta">@Autowired</span></span><br><span class="line">  <span class="hljs-keyword">private</span> MessageRepository repository;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">public</span> <span class="title function_">MessageService</span> <span class="hljs-params">(MessageRepository repository)</span> {</span><br><span class="line">    <span class="hljs-built_in">this</span>.repository = repository;</span><br><span class="line">  }</span><br><span class="line">  ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-3-의존성-주입-모범-사례"><a href="#3-3-의존성-주입-모범-사례" class="headerlink" title="3.3. 의존성 주입 모범 사례"></a>3.3. 의존성 주입 모범 사례</h3><p>의존성은 항상 생성자를 통해 주입해야 합니다. 이를 통해 생성 이후에 인스턴스는 완전히 초기화되고 주입된 의존성은 읽기 전용이 됩니다.  </p>
<p>필드 기반 주입은 사용하지 않아야 합니다. 스프링은 자바 리플렉션(Reflection)으로 필드를 주입하고 필드 주입 방식을 사용하는 것은 위험한 것으로 간주합니다. 또한 의존성을 초기화하고 관리하는 방법과 이들의 의존 관계와 같은 의존성의 정보를 숨기며 필드 주입은 매우 간단하지만 너무 많은 의존성을 필드 주입으로 추가하면 단일 책임 원칙(SRP)을 위반할 수 있습니다.</p>
<h2 id="4-스프링-MVC"><a href="#4-스프링-MVC" class="headerlink" title="4. 스프링 MVC"></a>4. 스프링 MVC</h2><p>스프링 MVC는 웹 애플리케이션을 구현하는 기술을 제공합니다. 이것은 자바 EE 서블릿 API를 기반으로합니다.</p>
<h3 id="4-1-Java-EE-Enterprise-Edition"><a href="#4-1-Java-EE-Enterprise-Edition" class="headerlink" title="4.1 Java EE(Enterprise Edition)"></a>4.1 Java EE(Enterprise Edition)</h3><p>Spring은 Java EE 애플리케이션을 만들기 위한 프레임워크입니다.<br>Java EE란 Java SE에 웹 기능을 추가한 플랫폼입니다. 이전에는 J2EE라 불렸으나 버전 5.0 이후 Java EE로 개칭되었습니다.<br>이러한 Java EE 기술 사양을 준수해서 만든 서버를 WAS(Web Application Server)라 합니다.</p>
<h3 id="4-2-자바-EE-서블릿-Servlet"><a href="#4-2-자바-EE-서블릿-Servlet" class="headerlink" title="4.2 자바 EE 서블릿(Servlet)"></a>4.2 자바 EE 서블릿(Servlet)</h3><p>서블릿이란 CGI(Common Gateway Interface)의 일종입니다. CGI란 프로그래밍 언어가 웹 서버에서 동적인 페이지를 보여주기 위한 기술 중 하나입니다. Servlet의 경우 자바와 CGI가 합쳐진 기술입니다.  </p>
<p>자바 EE 서블릿(이하 “서블릿”이라 합니다.)은 톰캣과 같은 애플리케이션 서버인 서블릿 컨테이너 내에서 동작합니다. HTTP 요청이 서버에 도착하면 일반적으로 인증, 로깅, 감사와 같은 필터링 작업을 수행하는 필터 리스트를 통과합니다. 요청이 모든 필터를 통과하면 애플리케이션 서버는 특정 패턴과 일치하는 URI를 포함하는 요청을 처리할 수 있게 등록된 서블릿으로 요청을 넘겨줍니다. 서블릿이 요청에 대한 처리를 마치면 HTTP 응답은 해당 HTTP 요청을 처리한 같은 필터 세트를 통과한 후 클라이어트로 다시 전송됩니다.  </p>
<p>자바 EE에서 모든 HTTP 요청에 대해 HttpServletRequest 인스턴스가 생성됩니다. 그리고 모든 HTTP 응답에 대해 HttpServletResponse 인스턴스가 생성됩니다. 여러 요청에서 사용자를 식별하기 위해 애플리케이션 서버는 첫 번째 요청을 받으면 HttpSession 인스턴스를 생성합니다. 각 HttpSession 인스턴스는 세션(Session) ID라고 부르는 ID를 가집니다. 세션 ID는 HTTP 응답 헤더의 클라이언트에 쿠키로 전송됩니다. 클라이언트는 그 쿠키를 저장하고 다음 요청 시 다시 서버로 보냅니다. 이렇게 해서 서버는 쿠키에서 찾은 세션 ID로 HttpSession 인스턴스를 조회해 사용자를 인식할 수 있습니다.  </p>
<p>자바 EE에서 HttpSessionListener 인터페이스를 구현해 HttpSession의 라이프 사이클 이벤트를 수신하거나 ServletRequestListener 인터페이스를 구현해 요청에 대한 라이프 사이클 이벤트를 수신하는 리스너를 만들 수 있습니다.  </p>
<p>서블릿은 생성하기 위해 javax.servlet.http.HttpServlet을 확장하고 @WebServlet 어노테이션을 적용하거나 전통 방식으로 자바 EE 웹 애플리케이션의 설정 파일인 web.xml 파일에 등록할 수 있습니다. 어느 방법이든, 서버가 일치하는 URI 요청을 라우트할 수 있게 서블릿을 하나 이상의 URI 패턴에 매핑해야합니다.  </p>
<p>또한 서블릿에서 doGet, doPost, doPut, doDelete 메소드를 재정의할 수 있습니다. 이러한 메소드의 내부는 애플리케이션의 로직이 시작되는 위치가 됩니다. 또한 서블릿을 사용할 때 in-memory 데이터 또는 I/O 수행과 같은 같은 공유 리소스에 접근해야 한다면 서블릿이 항상 동시 요청을 다루고, 하나의 요청에 의한 변경 사항이 다른 요청에 영향을 줄 수 있다는 사실을 기억해야 합니다.</p>
<h3 id="4-3-DispatcherServlet"><a href="#4-3-DispatcherServlet" class="headerlink" title="4.3 DispatcherServlet"></a>4.3 DispatcherServlet</h3><p>스프링 MVC에서는 클래스를 생성해 @Controller 어노테이션을 추가하고 @RequestMapping 어노테이션으로 특정 URI 패턴에 매핑하여 서블릿을 대신할 수 있습니다. 규약에 따르면 클래스 이름은 보통 Controller로 끝납니다. 스프링은 요청을 받기 위해 DispatcherServlet을 활용합니다. DispatcherServlet은 모든 요청을 처리할 수 있게 설정해야 하며 @RequestMapping 어노테이션에 지정된 URI 패턴에 따라 스프링 요청을 처리할 패턴에 맞는 컨트롤러를 찾아갑니다.</p>
<h3 id="4-4-뷰-Views"><a href="#4-4-뷰-Views" class="headerlink" title="4.4 뷰(Views)"></a>4.4 뷰(Views)</h3><p>일반적으로 웹 애플리케이션에서 웹 페이지를 렌더링할 때 브라우저에 HTML 코드를 보내거나 API 호출의 결과로 JSON 데이터를 보냅니다. HTML 코드와 JSON 데이터는 모두 HTTP 응답으로 전달되는 String 객체입니다.</p>
<h3 id="4-5-MVC-패턴"><a href="#4-5-MVC-패턴" class="headerlink" title="4.5 MVC 패턴"></a>4.5 MVC 패턴</h3><p>C는 컨트롤러(Controller), V는 HTML 마크업이 위치하는 뷰(View)입니다. M은 컨트롤러가 생성하고 HTTP 응답을 통해 클라이언트에 전송되어 뷰가 최종 결과를 렌더링하는데 사용할 수 있는 데이터를 포함하는 모델(Model)입니다.</p>
<h2 id="5-필터-Filter"><a href="#5-필터-Filter" class="headerlink" title="5. 필터(Filter)"></a>5. 필터(Filter)</h2><p>다음 예제 필터는 디자인 패턴인 책임 연쇄 패턴(Chain of Responsibility)을 구현한 것입니다. 서블릿에 도달하기 전에 HTTP 요청에 대한 필터링 작업을 수행하려고 할 때 유용합니다. 감사(audit) 요청에 대한 AudtingFilter를 만들려면 javax.servlet.Filter 인터페이스를 구현해야 합니다. 또는 스프링의 org.springframework.web.filter.GenericFilterBean을 확장해서 필터를 만들 수도 있습니다.</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="title class_">AuditingFilter</span> <span class="hljs-keyword">extends</span> <span class="title class_">GenericFilterBean</span> {</span><br><span class="line">  <span class="hljs-meta">@Override</span></span><br><span class="line">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="title function_">doFilter</span><span class="hljs-params">(ServletRequest req, ServletResponse res, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException {</span><br><span class="line">    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="title class_">Date</span>().getTime();</span><br><span class="line">    chain.doFilter(req, res);</span><br><span class="line">    <span class="hljs-type">long</span> <span class="hljs-variable">elapsed</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="title class_">Date</span>().getTime() - start;</span><br><span class="line">    <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> (HttpServletRequest) req;</span><br><span class="line">    logger.debug(<span class="hljs-string">"Request[uri="</span> + request.getRequestURI() + <span class="hljs-string">", method="</span>+ request.getMethod() + <span class="hljs-string">"] completed in "</span> + elapsed + <span class="hljs-string">" ms"</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>보다시피 AuditingFilter는 GenericFilterBean을 확장하고 필터링 작업을 수행하는 doFilter() 메소드를 재정의합니다. doFilter()는 체인에 실행할 필터가 존재하면 추가 필터를 호출할 수 있게 합니다.</p>
<h2 id="6-스프링-JDBC-Java-Database-Connectivity-JPA-Java-Persistence-API"><a href="#6-스프링-JDBC-Java-Database-Connectivity-JPA-Java-Persistence-API" class="headerlink" title="6. 스프링 JDBC(Java Database Connectivity), JPA(Java Persistence API)"></a>6. 스프링 JDBC(Java Database Connectivity), JPA(Java Persistence API)</h2><p>JDBC(Java Database Connectivity) API는 관계형 데이터베이스에 저장된 데이터에 접근하는 방법을 정의합니다. JDBC 드라이버는 특정 데이터베이스에 대한 JDBC API의 구현체입니다. JPA(Java Persistence API)는 자바 객체의 영속성을 위한 자바의 표준화된 접근 방식을 정의합니다. 이 방식은 객체 지향 모델과 관계형 데이터베이스에 저장된 데이터 사이의 간격을 메우기 위해 객체 관계형 매핑(ORM, Object-Relational Mapping) 메커니즘을 사용합니다. 하이버네이트(Hibernate) ORM은 가장 흔히 사용하는 JPA 표준을 구현한 구현체입니다. JDBC API는 데이터베이스와의 상호작용을 해결하지만, JPA는 객체 지향 방식으로 데이터베이스에 객체를 저장하고 가져오는 방법을 담당합니다.</p>
</body></html>
    
    </div>
    
    <div class="columns is-variable is-1 is-multiline is-mobile">
    
        <span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/Spring/">#Spring</a></span>
    
    </div>
    
    
    <div class="columns is-mobile is-multiline article-nav">
        <span class="column is-12-mobile is-half-desktop  article-nav-prev">
            
            <a href="/2022/07/16/Backend-Roadmap/Backend-Roadmap/">백엔드 로드맵(Backend Roadmap)</a>
            
        </span>
        <span class="column is-12-mobile is-half-desktop is-hidden-mobile article-nav-next">
            
        </span>
    </div>
    
</article>




    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2022 23enje&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a
                        target="_blank" rel="noopener" href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            
        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("ko");
</script>




<script src="/js/script.js"></script>


    
</body>
</html>